{"meta":{"title":"Hagrid Xu's Blog","subtitle":null,"description":"just another guy want to be a computer scientist","author":"Hagrid Xu","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-11-27T07:33:48.000Z","updated":"2018-11-27T07:54:21.866Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-27T07:36:54.000Z","updated":"2018-11-27T07:54:23.109Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"网络表示学习综述学习笔记","slug":"网络表示学习综述学习笔记","date":"2019-01-07T05:41:01.000Z","updated":"2019-01-07T05:42:29.608Z","comments":true,"path":"2019/01/07/网络表示学习综述学习笔记/","link":"","permalink":"http://yoursite.com/2019/01/07/网络表示学习综述学习笔记/","excerpt":"","text":"网络表示学习综述将网络信息转化为低维稠密的实数向量，并用于已有的机器学习算法的输入 G=(V,E) –&gt; Representation Learning –&gt;Network embeddings 在网络中拓扑结构相似的节点也应该具有相近的向量表示。 基于网络结构的网格表示学习 方法 简介 优缺点 谱聚类算法 计算关系矩阵的前K个特征向量或奇异向量来得到k纬的节点表示 依赖于关系矩阵的构建，时间复杂度与空间复杂度较高 局部线性表示 一个节点与它邻居的表示都位于该流形的一个局部线性的区域. 也就是说, 一个节点的表示可以通过它的邻居节点的表示的线性组合来近似得到. 使用邻居节点表示的加权和与中心节点表示的距离作为损失函数. 最小化损失函数的优化问题最终转化成某个关系矩阵特征向 量计算问题求解. || Laplace 特征表 | 假设两个相连的节点的表示应该相近 | 转化为 Laplace 矩阵的特征向量计算问题. || 有向图表示 | 扩展了 Laplace 特征表方法, 给不同点的损失函数以不同的权重 | || | 模块性意味着在同一模块内节点连接紧密, 而不同模块间节点连接稀疏. | 最终该优化问题转化为了归一化的 Laplace 矩阵的特征向量计算. | 这一类方法最主要的缺点在于复杂度: 大规模矩阵的特征向量计算是非常消耗计算时间和空间。 基于简单神经网络的算法DeepWalk算法充分利用网络结构中的随机游走序列的信息。首先在网络上采样生成大量的随机游走序列, 然后用 Skip-gram 和 Hierarchical Softmax 模东型对随机游走序列中每个局部窗口内的节点对进行概率建模, 最大化随机游走序列的似然概率, 并最终使用随机梯度下降学习参数. 只依赖于局部信息，适用于分布式和在线系统 1对比0-1二值邻接矩阵，方差与不确定性降低 Word2vec应用于随机游走序列 一种可以适用于大规模的有向带权图的网络表示学习算法. 为了对节点间的关系进行建模, LINE算法用观察到的节点间连接刻画了第一级相似度关系, 用不直接相连的两个节点的共同邻居刻画了这两个点之间的第二级相似度关系. 直觉上说, 对直接相连的两个节点间关系的刻画等价于对原始网络的邻接矩阵的建模. 但是一个网络中的边关系往往是非常稀疏的, 所以有必要进一步刻画第二级相似度关系来考虑 基于矩阵分解的方法给定关系矩阵, 对关系矩阵进行矩阵分解达到降维的效果, 从而得到节点的网络表示。（DeepWalk 算法实际上等价于某个特定关系矩阵的矩阵分解） GraRep算法GraRep 通过 SVD 分解对该关系矩阵进行降维从而得到 k 步网络表示。对邻接矩阵 A 进行行归一化处理, 使得矩阵 A 中每行的加和等于 1. 则 GraRep 算法在计算 k 步网络表示时分解了矩阵 Ak, 该关系矩阵中的每个单元对应着两个节点间通过 k 步的随机游走抵达的概率。 算法框架: 第一步构建节点间的关系矩阵, 第二步对该矩阵进行矩阵分解操作得到网络表示 基于社区发现的算法让节点表示的每一维对应该节点从属于一个社区的强度, 然后设计最优化目标进行求解. BIGCLAM 算法对网络中每条边的生成概率进行建模: 两个点的向量表示内积越大, 那么这两个点之间形成边的概率也就越高. 算法的最大化目标是整个网络结构的最大似然概率. 最优化求解参数的过程由随机梯度下降算法实现. 保存特殊性质的网络表示 大多数网络表示学习方法使用向量表示间的内积或者余弦距离刻画节点相似度. 但内积或者余弦距离都是无向的, 会丢失网络中的非对称性. 另一方面, 一些依赖于网络结构定义的性质, 如社区 (community)等信息, 也会在网络表示学习的过程中丢失。 HOPE 算法 [21] 为每个节点刻画了两种不同的表示, 并着眼于保存原始网络中的非对称性信息.构建了不同的非对称的关系矩阵, 然后使用 JDGSVD 算法进行矩阵降维得到节点的网络表示. CNRL 算法 [22] 考虑了在节点表示中嵌入网络隐藏的社区信息. 假设每个节点属于多个社区, 也就是每个节点在所有的社区上有一个概率分布。CNRL 将网络中的社区看作文本中的主题, 也就是说, 网络中相关的节点倾向于行程社区, 而文本中相关的词则会构成主题. 因此, CNRL 算法在生成的随机游走序列上, 将每个节点序列看成一篇文档, 通过基于 Gibbs 采样的 LDA [23] 来学习每个节点的社区分布, 并通过随机采样的方式, 来给序列中的节点分配其对应的社区标签. 结合外部信息 文本信息、标签分类 半监督节点分类任务：一种半监督的网络表示学习方法 MMDW，会针对分类边界上的支持向量计算其偏置向量, 使其在学习过程中向正确的类别方向进行偏置, 从而增大表示向量的区分能力. 结合边上的标签信息：TransNet 假设头结点表示向量加上关系表示向量等于尾节点表示向量. 其中, 通过关键词抽取、命名实体识别等方式, 对交互文本抽取出标签集合来表示关系. 随后, 通过深层自动编码器对标签集合进行压缩, 来得到关系的表示向量. 该模型能够有效地预测未标注的边上的标签集合, 在社会关系抽取任务上取得了显著的提升.","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://yoursite.com/categories/自然语言处理/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"知识表示方法","slug":"知识表示方法","permalink":"http://yoursite.com/tags/知识表示方法/"},{"name":"网络表示学习","slug":"网络表示学习","permalink":"http://yoursite.com/tags/网络表示学习/"}]},{"title":"知识表示学习研究论文总结","slug":"知识表示学习研究论文总结","date":"2019-01-04T08:09:07.000Z","updated":"2019-01-04T08:10:21.935Z","comments":true,"path":"2019/01/04/知识表示学习研究论文总结/","link":"","permalink":"http://yoursite.com/2019/01/04/知识表示学习研究论文总结/","excerpt":"","text":"知识表示 网络形式：节点表示实体、边表示实体间的关系（example: RDF） 表示学习：语义信息表示为稠密低维实向量值 知识表示学习：面向知识库的实体和关系进行表示学习 表示学习的目的：将研究对象的语义信息表示为低维稠密向量，计算两个对象向量之间的语义相似度 表示学习的应用： 相似度计算 知识图谱补全（知识库的链接） 关系抽取、自动问答、实体链接 主要方法E：实体 R：关系 S: $ERE$ 3元组 模型名称 简述 特点、注释、缺点 损失函数 距离模型 每个实体用d纬向量表示，所有实体投影到d维向量空间 将头向量和尾向量通过关系r的两个矩阵投影到r空间中再计算向量距离 $f_r(h,t) = M_{r,1}l_h-M_{r,2}l_t _{L_1}$ 单层神经网络模型 采用单层神经网络的非线性操作来减轻距离模型无法协同精确刻画实体与关系的语义联系问题 将双重模型的改进模板，提供了微弱的联系，确引入了更高的计算复杂度 能量模型 每个实体和关系都用低维向量表示 两个评分函数：线性+双线性 双线性模型 刻画实体和关系之间的二阶联系，双线性评分函数 通过简单的方法刻画了实体和关系的语义联系，协同性较好，计算复杂度低 $f_r(h,t)={l_h}^tM_rl_t$ 张量神经网络模型 用双线性张量取代传统神经网络中的线性变换层，在不同的纬度下将头、尾实体向量联系起来。 注：实体向量是该实体中所有单词向量的平均值。计算复杂度高、系数上结果差 矩阵分解模型 翻译模型 词向量空间存在平移不变现象 捕捉单词之间的隐含语义关系，简单有效，在大规模稀疏知识图谱上，性能惊人 $C(king)-C(queen) \\approx C(man)-C(woman)$ 全息表示模型 刚刚提出，效果未验证、值得关注 注：比较详细见论文 复杂关系建模翻译模型（TransE）：处理复杂关系时性能显著降低（1-N、N-1、N-N） 美国-总体-奥巴马 美国-总统-布什 TransE将会把奥巴马与布什的向量变的相同 TransH 让一个实体在不同的关系下拥有不同的表示 对于关系r，同时用平移向量l_r和超平面法向量w_r来表示它。 TransR 一个实体是多种属性的综合体，不同关系关注实体的不同属性。 不同的关系拥有不同的语义空间、对每个三元组，将实体投影到对应的关系空间中，然后再建立从头实体到尾实体的翻译关系。 缺点： 同一个关系r下，头、尾实体共享相同的投影矩阵 从实体空间到关系空间的投影是实体和关系之间的交互过程，因此投影矩阵只和关系有关不合理（需要结合实体信息） 复杂度太高 TransD 利用2个投影向量构建投影矩阵，解决TransR模型参数过多问题 TransA 将损失函数改成马氏距离，并为每一纬学习不同的权重 DKRL文本表示 利用CBOW或者CNN根据实体描述文本得到实体表示，再用于TransE的目标函数学习 CBOW：将文本中的词向量简单相加 CNN：能够考虑文本中的次序信息 可以利用TransE学习知识库中的知识表示，同时利用维基百科正文中的链接信息，让文本实体对应的词表示与知识库中的实体表示尽可能相近。 未来 不同类型知识表示学习（不仅是1-N、N-N，还有树状等） 多源信息融合 复杂推理","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://yoursite.com/categories/自然语言处理/"}],"tags":[{"name":"知识表示方法","slug":"知识表示方法","permalink":"http://yoursite.com/tags/知识表示方法/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"},{"name":"相似度计算","slug":"相似度计算","permalink":"http://yoursite.com/tags/相似度计算/"}]},{"title":"从wordembedding到bert 思维导图","slug":"思维导图","date":"2018-12-25T01:26:22.000Z","updated":"2018-12-25T02:15:23.275Z","comments":true,"path":"2018/12/25/思维导图/","link":"","permalink":"http://yoursite.com/2018/12/25/思维导图/","excerpt":"","text":"from:https://zhuanlan.zhihu.com/p/49271699 预训练在训练集上学会网络参数，存起来以后备用。在比较浅层的CNN结构参数初始化的时候可以用之前存的参数，高层任然初始化。 这时有两种做法 一种是浅层加载的参数在训练C任务过程中不动，这种方法被称为“Frozen”; 另外一种是底层网络参数尽管被初始化了，在C任务训练过程中仍然随着训练的进程不断改变，这种一般叫“Fine-Tuning”，顾名思义，就是更好地把参数进行调整使得更适应当前的C任务。 如果手头任务C的训练集合数据量较少的话，现阶段的好用的CNN比如Resnet/Densenet/Inception等网络结构层数很深，几百万上千万参数量算起步价，上亿参数的也很常见，训练数据少很难很好地训练这么复杂的网络，但是如果其中大量参数通过大的训练集合比如ImageNet预先训练好直接拿来初始化大部分网络结构参数，然后再用C任务手头比较可怜的数据量上Fine-tuning过程去调整参数让它们更适合解决C任务，这样原先训练不了的任务就能解决了，即使手头任务训练数据也不少，加个预训练过程也能极大加快任务训练的收敛速度。 Word EmbeddingWord2Vec Word2Vec有两种训练方法，一种叫CBOW，核心思想是从一个句子里面把一个词抠掉，用这个词的上文和下文去预测被抠掉的这个词；第二种叫做Skip-gram，和CBOW正好反过来，输入某个单词，要求网络预测它的上下文单词。 多义词Bank，有两个常用含义，但是Word Embedding在对bank这个单词进行编码的时候，是区分不开这两个含义的，因为它们尽管上下文环境中出现的单词不同，但是在用语言模型训练的时候，不论什么上下文的句子经过word2vec，都是预测相同的单词bank，而同一个单词占的是同一行的参数空间，这导致两种不同的上下文信息都会编码到相同的word embedding空间里去。所以word embedding无法区分多义词的不同语义，这就是它的一个比较严重的问题。 ELMOEmbedding from Language Models（Deep contextualized word representation） ELMO的本质思想是：我事先用语言模型学好一个单词的Word Embedding，此时多义词无法区分，不过这没关系。在我实际使用Word Embedding的时候，单词已经具备了特定的上下文了，这个时候我可以根据上下文单词的语义去调整单词的Word Embedding表示，这样经过调整后的Word Embedding更能表达在这个上下文中的具体含义，自然也就解决了多义词的问题了。所以ELMO本身是个根据当前上下文对Word Embedding动态调整的思路。 那么站在现在这个时间节点看，ELMO有什么值得改进的缺点呢？ 首先，一个非常明显的缺点在特征抽取器选择方面，ELMO使用了LSTM而不是新贵Transformer，Transformer是谷歌在17年做机器翻译任务的“Attention is all you need”的论文中提出的，引起了相当大的反响，很多研究已经证明了Transformer提取特征的能力是要远强于LSTM的。如果ELMO采取Transformer作为特征提取器，那么估计Bert的反响远不如现在的这种火爆场面。 另外一点，ELMO采取双向拼接这种融合特征的能力可能比Bert一体化的融合特征方式弱，但是，这只是一种从道理推断产生的怀疑，目前并没有具体实验说明这一点。 GPTGenerative Pre-Training GPT也采用两阶段过程，第一个阶段是利用语言模型进行预训练，第二阶段通过Fine-tuning的模式解决下游任务。上图展示了GPT的预训练过程，其实和ELMO是类似的，主要不同在于两点：首先，特征抽取器不是用的RNN，而是用的Transformer，上面提到过它的特征抽取能力要强于RNN，这个选择很明显是很明智的；其次，GPT的预训练虽然仍然是以语言模型作为目标任务，但是采用的是单向的语言模型，所谓“单向”的含义是指：语言模型训练的任务目标是根据 单词的上下文去正确预测单词 ， 之前的单词序列Context-before称为上文，之后的单词序列Context-after称为下文。ELMO在做语言模型预训练的时候，预测单词 同时使用了上文和下文，而GPT则只采用Context-before这个单词的上文来进行预测，而抛开了下文。 上图展示了GPT在第二阶段如何使用。首先，对于不同的下游任务来说，本来你可以任意设计自己的网络结构，现在不行了，你要向GPT的网络结构看齐，把任务的网络结构改造成和GPT的网络结构是一样的。然后，在做下游任务的时候，利用第一步预训练好的参数初始化GPT的网络结构，这样通过预训练学到的语言学知识就被引入到你手头的任务里来了，这是个非常好的事情。再次，你可以用手头的任务去训练这个网络，对网络参数进行Fine-tuning，使得这个网络更适合解决手头的问题。就是这样。看到了么？这有没有让你想起最开始提到的图像领域如何做预训练的过程（请参考上图那句非常容易暴露年龄的歌词）？对，这跟那个模式是一模一样的。 那么站在现在的时间节点看，GPT有什么值得改进的地方呢？其实最主要的就是那个单向语言模型，如果改造成双向的语言模型任务估计也没有Bert太多事了。当然，即使如此GPT也是非常非常好的一个工作，跟Bert比，其作者炒作能力亟待提升。 TransformerTransformer是个叠加的“自注意力机制（Self Attention）”构成的深度网络，是目前NLP里最强的特征提取器，注意力这个机制在此被发扬光大。 如果不了解注意力机制你肯定会落后时代的发展。而介绍Transformer比较好的文章可以参考以下两篇文章：一个是Jay Alammar可视化地介绍Transformer的博客文章The Illustrated Transformer ，非常容易理解整个机制，建议先从这篇看起；然后可以参考哈佛大学NLP研究组写的“The Annotated Transformer. ”，代码原理双管齐下，讲得非常清楚。我相信上面两个文章足以让你了解Transformer了，所以这里不展开介绍。 其次，我的判断是Transformer在未来会逐渐替代掉RNN成为主流的NLP工具，RNN一直受困于其并行计算能力，这是因为它本身结构的序列性依赖导致的，尽管很多人在试图通过修正RNN结构来修正这一点，但是我不看好这种模式，因为给马车换轮胎不如把它升级到汽车，这个道理很好懂，更何况目前汽车的雏形已经出现了，干嘛还要执着在换轮胎这个事情呢？是吧？再说CNN，CNN在NLP里一直没有形成主流，CNN的最大优点是易于做并行计算，所以速度快，但是在捕获NLP的序列关系尤其是长距离特征方面天然有缺陷，不是做不到而是做不好，目前也有很多改进模型，但是特别成功的不多。综合各方面情况，很明显Transformer同时具备并行性好，又适合捕获长距离特征，没有理由不在赛跑比赛中跑不过RNN和CNN。 BertBert采用和GPT完全相同的两阶段模型，首先是语言模型预训练；其次是使用Fine-Tuning模式解决下游任务。和GPT的最主要不同在于在预训练阶段采用了类似ELMO的双向语言模型，当然另外一点是语言模型的数据规模要比GPT大。所以这里Bert的预训练过程不必多讲了。 绝大部分NLP问题可以归入上图所示的四类任务中： 一类是序列标注，这是最典型的NLP任务，比如中文分词，词性标注，命名实体识别，语义角色标注等都可以归入这一类问题，它的特点是句子中每个单词要求模型根据上下文都要给出一个分类类别。 第二类是分类任务，比如我们常见的文本分类，情感计算等都可以归入这一类。它的特点是不管文章有多长，总体给出一个分类类别即可。 第三类任务是句子关系判断，比如Entailment，QA，语义改写，自然语言推理等任务都是这个模式，它的特点是给定两个句子，模型判断出两个句子是否具备某种语义关系； 第四类是生成式任务，比如机器翻译，文本摘要，写诗造句，看图说话等都属于这一类。它的特点是输入文本内容后，需要自主生成另外一段文字。 对于种类如此繁多而且各具特点的下游NLP任务，Bert如何改造输入输出部分使得大部分NLP任务都可以使用Bert预训练好的模型参数呢？上图给出示例，对于句子关系类任务，很简单，和GPT类似，加上一个起始和终结符号，句子之间加个分隔符即可。对于输出来说，把第一个起始符号对应的Transformer最后一层位置上面串接一个softmax分类层即可。对于分类问题，与GPT一样，只需要增加起始和终结符号，输出部分和句子关系判断任务类似改造；对于序列标注问题，输入部分和单句分类是一样的，只需要输出部分Transformer最后一层每个单词对应位置都进行分类即可。从这里可以看出，上面列出的NLP四大任务里面，除了生成类任务外，Bert其它都覆盖到了，而且改造起来很简单直观。尽管Bert论文没有提，但是稍微动动脑子就可以想到，其实对于机器翻译或者文本摘要，聊天机器人这种生成式任务，同样可以稍作改造即可引入Bert的预训练成果。只需要附着在S2S结构上，encoder部分是个深度Transformer结构，decoder部分也是个深度Transformer结构。根据任务选择不同的预训练数据初始化encoder和decoder即可。这是相当直观的一种改造方法。当然，也可以更简单一点，比如直接在单个Transformer结构上加装隐层产生输出也是可以的。不论如何，从这里可以看出，NLP四大类任务都可以比较方便地改造成Bert能够接受的方式。这其实是Bert的非常大的优点，这意味着它几乎可以做任何NLP的下游任务，具备普适性，这是很强的。 那么新问题来了：对于Transformer来说，怎么才能在这个结构上做双向语言模型任务呢？乍一看上去好像不太好搞。我觉得吧，其实有一种很直观的思路，怎么办？看看ELMO的网络结构图，只需要把两个LSTM替换成两个Transformer，一个负责正向，一个负责反向特征提取，其实应该就可以。当然这是我自己的改造，Bert没这么做。那么Bert是怎么做的呢？我们前面不是提过Word2Vec吗？我前面肯定不是漫无目的地提到它，提它是为了在这里引出那个CBOW训练方法，所谓写作时候埋伏笔的“草蛇灰线，伏脉千里”，大概就是这个意思吧？前面提到了CBOW方法，它的核心思想是：在做语言模型任务的时候，我把要预测的单词抠掉，然后根据它的上文Context-Before和下文Context-after去预测单词。其实Bert怎么做的？Bert就是这么做的。从这里可以看到方法间的继承关系。当然Bert作者没提Word2Vec及CBOW方法，这是我的判断，Bert作者说是受到完形填空任务的启发，这也很可能，但是我觉得他们要是没想到过CBOW估计是不太可能的。 Bert创新Masked 语言模型和Next Sentence Prediction。而Masked语言模型上面讲了，本质思想其实是CBOW，但是细节方面有改进。 Masked双向语言模型向上图展示这么做：随机选择语料中15%的单词，把它抠掉，也就是用[Mask]掩码代替原始单词，然后要求模型去正确预测被抠掉的单词。但是这里有个问题：训练过程大量看到[mask]标记，但是真正后面用的时候是不会有这个标记的，这会引导模型认为输出是针对[mask]这个标记的，但是实际使用又见不到这个标记，这自然会有问题。为了避免这个问题，Bert改造了一下，15%的被上天选中要执行[mask]替身这项光荣任务的单词中，只有80%真正被替换成[mask]标记，10%被狸猫换太子随机替换成另外一个单词，10%情况这个单词还待在原地不做改动。这就是Masked双向语音模型的具体做法。 至于说“Next Sentence Prediction”，指的是做语言模型预训练的时候，分两种情况选择两个句子，一种是选择语料中真正顺序相连的两个句子；另外一种是第二个句子从语料库中抛色子，随机选择一个拼到第一个句子后面。我们要求模型除了做上述的Masked语言模型任务外，附带再做个句子关系预测，判断第二个句子是不是真的是第一个句子的后续句子。之所以这么做，是考虑到很多NLP任务是句子关系判断任务，单词预测粒度的训练到不了句子关系这个层级，增加这个任务有助于下游句子关系判断任务。所以可以看到，它的预训练是个多任务过程。这也是Bert的一个创新。 bert输入顺带讲解下Bert的输入部分，也算是有些特色。它的输入部分是个线性序列，两个句子通过分隔符分割，最前面和最后增加两个标识符号。每个单词有三个embedding:位置信息embedding，这是因为NLP中单词顺序是很重要的特征，需要在这里对位置信息进行编码；单词embedding,这个就是我们之前一直提到的单词embedding；第三个是句子embedding，因为前面提到训练数据都是由两个句子构成的，那么每个句子有个句子整体的embedding项对应给每个单词。把单词对应的三个embedding叠加，就形成了Bert的输入。 bert评价首先是两阶段模型，第一阶段双向语言模型预训练，这里注意要用双向而不是单向，第二阶段采用具体任务Fine-tuning或者做特征集成；第二是特征抽取要用Transformer作为特征提取器而不是RNN或者CNN；第三，双向语言模型可以采取CBOW的方法去做（当然我觉得这个是个细节问题，不算太关键，前两个因素比较关键）。Bert最大的亮点在于效果好及普适性强，几乎所有NLP任务都可以套用Bert这种两阶段解决思路，而且效果应该会有明显提升。可以预见的是，未来一段时间在NLP应用领域，Transformer将占据主导地位，而且这种两阶段预训练方法也会主导各种应用。 另外，我们应该弄清楚预训练这个过程本质上是在做什么事情，本质上预训练是通过设计好一个网络结构来做语言模型任务，然后把大量甚至是无穷尽的无标注的自然语言文本利用起来，预训练任务把大量语言学知识抽取出来编码到网络结构中，当手头任务带有标注信息的数据有限时，这些先验的语言学特征当然会对手头任务有极大的特征补充作用，因为当数据有限的时候，很多语言学现象是覆盖不到的，泛化能力就弱，集成尽量通用的语言学知识自然会加强模型的泛化能力。如何引入先验的语言学知识其实一直是NLP尤其是深度学习场景下的NLP的主要目标之一，不过一直没有太好的解决办法，而ELMO/GPT/Bert的这种两阶段模式看起来无疑是解决这个问题自然又简洁的方法，这也是这些方法的主要价值所在。 对于当前NLP的发展方向，我个人觉得有两点非常重要，一个是需要更强的特征抽取器，目前看Transformer会逐渐担当大任，但是肯定还是不够强的，需要发展更强的特征抽取器；第二个就是如何优雅地引入大量无监督数据中包含的语言学知识，注意我这里强调地是优雅，而不是引入，此前相当多的工作试图做各种语言学知识的嫁接或者引入，但是很多方法看着让人牙疼，就是我说的不优雅。目前看预训练这种两阶段方法还是很有效的，也非常简洁，当然后面肯定还会有更好的模型出现。","categories":[{"name":"NLP","slug":"NLP","permalink":"http://yoursite.com/categories/NLP/"}],"tags":[{"name":"Bert","slug":"Bert","permalink":"http://yoursite.com/tags/Bert/"}]},{"title":"cs231知识回顾总结","slug":"cs231知识回顾总结","date":"2018-12-11T08:14:41.000Z","updated":"2018-12-25T01:30:10.139Z","comments":true,"path":"2018/12/11/cs231知识回顾总结/","link":"","permalink":"http://yoursite.com/2018/12/11/cs231知识回顾总结/","excerpt":"","text":"图像分类流程 输入：输入是包含N个图像的集合，每个图像的标签是K种分类标签中的一种。这个集合称为训练集。 学习：这一步的任务是使用训练集来学习每个类到底长什么样。一般该步骤叫做训练分类器或者学习一个模型。 评价：让分类器来预测它未曾见过的图像的分类标签，并以此来评价分类器的质量。我们会把分类器预测的标签和图像真正的分类标签对比。毫无疑问，分类器预测的分类标签和图像真正的分类标签如果一致，那就是好事，这样的情况越多越好。 Nearest Neighbor分类器 L1距离 L2距离 k-Nearest Neighbor分类器 验证集 超参数调优（尝试不同的K值，不同的距离计算方法） 交叉验证（如果训练数据量不够，使用交叉验证方法，它能帮助我们在选取最优超参数的时候减少噪音） 线性分类简单来说平面空间中有点，划一条线。（与圈一个圈有区别） 基于参数的评分函数。该函数将原始图像像素映射为分类评分值（例如：一个线性函数）。 损失函数。该函数能够根据分类评分和训练集图像数据实际分类的一致性，衡量某个具体参数集的质量好坏。损失函数有多种版本和不同的实现方式（例如：Softmax或SVM）。 评分函数（参数parameters、权重weights、偏差向量bias vector） 偏差与权重的合并（矩阵计算的合并） 归一处理（预处理） 与kNN分类器不同，参数方法的优势在于一旦通过训练学习到了参数，就可以将训练数据丢弃了。同时该方法对于新的测试数据的预测非常快，因为只需要与权重W进行一个矩阵乘法运算。 损失函数 SVM 正则化 softmax分类器 针对一个数据点，SVM和Softmax分类器的不同处理方式的例子。两个分类器都计算了同样的分值向量f（本节中是通过矩阵乘来实现）。不同之处在于对f中分值的解释：SVM分类器将它们看做是分类评分，它的损失函数鼓励正确的分类（本例中是蓝色的类别2）的分值比其他分类的分值高出至少一个边界值。Softmax分类器将这些数值看做是每个分类没有归一化的对数概率，鼓励正确分类的归一化的对数概率变高，其余的变低。SVM的最终的损失值是1.58，Softmax的最终的损失值是0.452，但要注意这两个数值没有可比性。只在给定同样数据，在同样的分类器的损失值计算中，它们才有意义。 Softmax分类器为每个分类提供了“可能性”：SVM的计算是无标定的，而且难以针对所有分类的评分值给出直观解释。Softmax分类器则不同，它允许我们计算出对于所有分类标签的可能性。举个例子，针对给出的图像，SVM分类器可能给你的是一个[12.5, 0.6, -23.0]对应分类“猫”，“狗”，“船”。而softmax分类器可以计算出这三个标签的”可能性“是[0.9, 0.09, 0.01]，这就让你能看出对于不同分类准确性的把握。 最优化 Optimization损失函数可以量化某个具体权重集W的质量。而最优化的目标就是找到能够最小化损失函数值的W 随机梯度下降 梯度计算计算梯度有两种方法：一个是缓慢的近似方法（数值梯度法），但实现相对简单。另一个方法（分析梯度法）计算迅速，结果精确，但是实现时容易出错，且需要使用微分。 使用有限差值近似计算梯度比较简单，但缺点在于终究只是近似（因为我们对于h值是选取了一个很小的数值，但真正的梯度定义中h趋向0的极限），且耗费计算资源太多。第二个梯度计算方法是利用微分来分析，能得到计算梯度的公式（不是近似），用公式计算梯度速度很快，唯一不好的就是实现的时候容易出错。为了解决这个问题，在实际操作时常常将分析梯度法的结果和数值梯度法的结果作比较，以此来检查其实现的正确性，这个步骤叫做梯度检查。 https://zhuanlan.zhihu.com/p/21387326?refer=intelligentunit 反向传播反向传播是利用链式法则递归计算表达式的梯度的方法。理解反向传播过程及其精妙之处，对于理解、实现、设计和调试神经网络非常关键。 https://zhuanlan.zhihu.com/p/21407711?refer=intelligentunit 神经网络常用基础函数 sigmoid tanh ReLU leaky ReLU Maxout 灵活地组织层 fully connect layer全连接层 输出层 隐藏层 数据预处理 均值减法 归一 PCA和白化whitening 权重初始化：用小随机数来初始化，而不是置0 偏置初始化：一般置0 批量归一化（Batch Normalization）让激活数据在训练开始前通过一个网络，网络处理数据使其服从标准高斯分布。在实现层面，应用这个技巧通常意味着全连接层（或者是卷积层，后续会讲）与激活函数之间添加一个BatchNorm层。 正则化 RegularizationL2正则化 L1正则化 最大范式约束 随机失活 https://zhuanlan.zhihu.com/p/21560667?refer=intelligentunit 梯度检查中心化公式+相对误差 使用双精度浮点数 保持浮点数的有效范围 目标函数的不可导点 检查时关闭dropout与augmentation https://zhuanlan.zhihu.com/p/21741716?refer=intelligentunit https://zhuanlan.zhihu.com/p/21798784?refer=intelligentunit 卷积神经网络卷积层 汇聚层 归一化层 全连接层 全连接层转化成卷积层 https://zhuanlan.zhihu.com/p/22038289?refer=intelligentunit","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[{"name":"cs231n","slug":"cs231n","permalink":"http://yoursite.com/tags/cs231n/"},{"name":"神经网络","slug":"神经网络","permalink":"http://yoursite.com/tags/神经网络/"}]},{"title":"2018.11.01-09学习知识列表","slug":"2018-11-01-09学习知识列表","date":"2018-11-09T05:56:32.000Z","updated":"2018-11-27T07:38:50.348Z","comments":true,"path":"2018/11/09/2018-11-01-09学习知识列表/","link":"","permalink":"http://yoursite.com/2018/11/09/2018-11-01-09学习知识列表/","excerpt":"","text":"11.1 组会讨论 11.2 cs231n：神经网络笔记：Nesterov动量更新方法，学习率衰减方法，超参数调优，迁移学习 11.5 自然语言处理：语料库与语言知识库 11.6 自然语言处理：语言模型章节的各种平滑方法 nature DL 综述 latex写作业 周五课程ppt 11.7 自然语言处理：推导语言模型章节的公式 cs61a：week1课程 11.8 周会报告 深度学习与知识图谱5.1–5.2 python leetcode 11.9 自然语言处理：概率图模型（贝叶斯模型、马尔可夫模型） 回顾一个月的学习内容","categories":[{"name":"学习知识列表","slug":"学习知识列表","permalink":"http://yoursite.com/categories/学习知识列表/"}],"tags":[{"name":"学习知识列表","slug":"学习知识列表","permalink":"http://yoursite.com/tags/学习知识列表/"}]},{"title":"2018.10学习知识列表","slug":"2018-10学习知识列表","date":"2018-11-09T05:40:01.000Z","updated":"2018-11-27T07:38:51.712Z","comments":true,"path":"2018/11/09/2018-10学习知识列表/","link":"","permalink":"http://yoursite.com/2018/11/09/2018-10学习知识列表/","excerpt":"","text":"week1 知识图谱发展报告 中文信息发展报告 week2 cs231n 第一、二周课程与笔记：发展、目标识别、图像分类、线性分类 机器学习书籍：模型评估和选择 cs231n 第三周课程：损失函数与优化SVM、Softmax、最优化方法的随机搜索、随机局部搜索、跟随梯度搜索 python 与 numpy tutorial cs231n偏差和权重、PCA latex安装学习 cs231n第4周课程：反向传播、梯度计算 week3 神经概率语言模型论文：n-gram、词向量，神经网络词序与梯度下降优化、异步实现 jupyter 人工智能ppt 数学之美：自然语言处理传统方法，中文分词，隐马尔可夫模型 week4 cs231n：卷积与池化 数学之美：上下文相关判定歧义、搜索引擎排名、有限状态机、最大熵迭代算法、余弦定理相似度、TF-IDF R-SVM+：Robust Learning with privileged information cs231n：Relu激活函数、正则化解决过拟合问题，学习率设置防止神经元死亡 cncc大会 cs231n：数据预处理、权重初始化，assignment1 KNN实现 学习numpy官方使用文档 Week5（29，30，31） 统计自然语言处理 交叉验证 批量归一化，BatchNorm SVM zsh leetcode","categories":[{"name":"学习知识列表","slug":"学习知识列表","permalink":"http://yoursite.com/categories/学习知识列表/"}],"tags":[{"name":"学习知识列表","slug":"学习知识列表","permalink":"http://yoursite.com/tags/学习知识列表/"}]}]}